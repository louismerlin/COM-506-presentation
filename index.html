<!DOCTYPE html>
<html>
  <head>
    <title>checkm8 exploit & checkra1n jailbreak</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Overpass:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Overpass+Mono:400,700,400italic);

      body { font-family: 'Overpass'; }

      h1, h2, h3 {
        font-weight: normal;
      }

      .remark-code, .remark-inline-code { font-family: 'Overpass Mono'; }

      @page {
        size: 1210px 681px;
        margin: 0;
      }
        
      @media print {
        .remark-slide-scaler {
          width: 100% !important;
          height: 100% !important;
          transform: scale(1) !important;
          top: 0 !important;
          left: 0 !important;
        }
      }

      .remark-slide {
        background: white;
      }

      .remark-slide-content {
        background: url(https://www.epfl.ch/campus/services/communication/wp-content/uploads/2019/03/EPFL-Corp-ID-New-Visual-Identity-Logo.png) no-repeat bottom left;
        background-size: 256px;
        background-position: -50px 552px;
        font-size: 25px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# checkm8 exploit<br />&<br />checkra1n jailbreak
#### Student seminar: security protocols and applications
#### 03/2020
##### Louis Merlin (247565)

---

# Plan

### 1. What is a jailbreak ?
### 2. How did this exploit start ?
### 3. How does the jailbreak work ?

---

# 1. What is a jailbreak ?
???
First, what do I mean by jailbreak ?
--

### - Privilege escalation on Apple's iOS
???
It typically involves some kind of privilege escalation on iOS, making the user root and able to bypass most of Apple's built in limitations.
--

### - Mobile carrier unlocking and device customization
???
A big usage of jailbreaking used to be for mobile carrier unlocking, if you wanted to switch your mobile carrier, say, from Swisscom to Salt or the other way around.

It is also used to install apps that are not on the Apple App Store, and tweak your device in different ways. I remember on one of the first versions of iOS, I used jailbreaking to change the background image of my iPod Touch from the only choice, black, to some picture I found cool at the time.
--

### - First jailbreak came out a few days after the first iPhone (2007)
???
Jailbreaks have played a big role in the iPhone from the beginning, as the first jailbreak was published only a few days after the release of the first iPhone. Since then, Apple has upgraded the security of the hardware and the software significantly. Some current versions of iOS and the iPhone have no public jailbreaks.
---

# 2. How did this exploit start ?
???
Now we can dive into the technical.
---

## 2.1 - ipwndfu and apollo.txt
### - Late 2019
### - Targets SecureROM (immutable code), so unpatchable
### - Leads to *checkra1n*
???
The exploit was first published in September 2019 by axi0mX in his pwn tool ipwndfu, although littlelailo claimed to have discovered it in March and published it in a text file.

It targets SecureROM, the first part of the iOS cold boot process, which is hard-coded in silicon, so unpatchable.

Over the months it was used to create a full jailbreak for iPhones 5s to X, named checkra1n.

---
# 3. How does the jailbreak work ?

## 3.1 - Normal use of DFU
- Start USB DFU protocol:
  - Input output buffer is allocated by the device in the ram
  - Address is given to usb stack via global variable
  - Image is transfered to the device
  - Image is copied to the memory location from where the boot will happen
  - Image is verified
- On DFU exit:
  - i/o buffer is freed
  - If parsing the image fails, the USB stack is activated again
???
SecureROM DFU image upload is used by Apple to bypass iBoot, the next part of the boot process, as an emergency recovery mecanism.

The image and its signature will be verified before it is used.

The signature is one of Apple's public keys, which are 2048-bit long RSA public keys.

---
## 3.2 - checkm8
- Start USB DFU protocol:
  - Input output buffer is allocated by the device in the ram
  - Address is given to usb stack via global variable
  - Image is transfered to the device <span style="color:tomato">INTERRUPT</span>
  - <s>Image is copied to the memory location from where the boot will happen</s>
  - <s>Image is verified</s>
- On DFU exit:
  - i/o buffer is freed <span style="color:tomato">=> use-after-free</span>
  - If parsing the image fails, the USB stack is activated again
???
Now let's talk about the actual checkm8 exploit.

After the USB stack is activated again, if we send the device data instead of a setup packet, the device will copy data on the dangling pointer.

---
## 3.3 - A8 and A9 processors
### - iPhone 6, 6+, 6s and 6s+
### - Use-after-free overwrites USB stack
### - USB tasks are a linked list of tasks
### - Overwrite the current task's **next** value, and create that next task
### - ðŸ™Œ
???
In the case of two processors, the A8 and the A9, we can directy overwrite the USB stack, and thus we have direct code execution.

Easy Peasy !

---
## 3.4 - The rest...
### - The ROM is deterministic, an the USB stack is not where we need it to be.

???
For the rest of the vulnerable processors, we can allocate and free data, but we do not get determinism on where the data is.

--
### - Heap Feng Shui to the rescue !
???
For this, we use Heap Feng Shui. The way the buffers are allocated is actually deterministic.
---

### Heap Feng Shui

```
def stall(device):
  libusb1_async_ctrl_transfer(device, 0x80, 6, 0x304,
                              0x40A, 'A' * 0xC0, 0.00001)
def leak(device):
  libusb1_no_error_ctrl_transfer(device, 0x80, 6, 0x304,
                                 0x40A, 0xC0, 1)
def no_leak(device):
  libusb1_no_error_ctrl_transfer(device, 0x80, 6, 0x304,
                                 0x40A, 0xC1, 1)
```

```
stall(device)
leak(device)
for i in range(6):
    no_leak(device)
dfu.usb_reset(device)
dfu.release_device(device)
```
???
So we launch multiple USB transfers at the same time, until the stars align and we can insert a gadget.

The "leak" invocation will create a hole in the RAM the size of a USB task, so that it will become the prefered place to put the USB task once the heap becomes full.
---

### Payload
```
0x1800B0000: t8010_shellcode  # initializing shell-code
...
0x1800B0180: t8010_handler  # new usb request handler
...
0x1800B0400: 0x1000006a5  # fake translation table descriptor
                          # matches the value in the original
                            translation table
...
0x1800B0600: 0x60000180000625  # fake translation table descriptor
                               # matches the value in the original
                                 translation table
0x1800B0608: 0x1800006a5  # fake translation table descriptor
                          # plus, in this descriptor,there are rights
                            for code execution
0x1800B0610: disabe_wxn_arm64  # code for disabling WXN
0x1800B0800: usb_rop_callbacks  # callback-chain
```
???
As you can see, the payload defines a few fake address translation tables, to take over the system.

WXN (Write permission implies Execute-never) is disabled which enables the code execution in RW memory.

The modified translation table makes WXN disabling code execution possible.
---

### Final steps of exploit
- Restore USB configuration
- USB Serial Number = "PWND:[checkm8]"
- Replace USB request handler pointer

???
We now restore the USB configuration to regain access to the device from the outside.

The shellcode then overwrites a few values to tell the hacker that the execution was successful.

Namely, the USB serial number is replaced with "PWND:[checkm8]"

Finaly, we initiate a new USB transfer for the bootkit to load and execute.
---

## 3.5 - The Bootkit

???
Trampoline ?

Chicken and egg ?

Dirty workaround, bzero ?

Retain code execution in usermode ? => Embed a tiny ramdisk in the shellcode


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
